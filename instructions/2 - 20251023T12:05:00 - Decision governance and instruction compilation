Authors: Jonathan Tran, OpenAI GPT-5

2. Decision governance and instruction compilation

2.1. Placement and immutability
2.1.1. Document instruction-level guidance in `instructions/` and architecture guidance in `architecture/`, grouping related decisions when practical.
2.1.2. Create new decision files for new topics instead of editing existing ones unless the user explicitly authorises an update.

2.2. File conventions
2.2.1. Name each decision file using the pattern `<N> - <DATETIME> - <SUBJECT>` where `<N>` matches the leading heading inside the file.
2.2.2. Begin every file with `Authors:` followed by all contributors, including the user when content is user-authored, user-requested, or derived from their earlier instructions.
2.2.3. Structure content with numbered sections and subsections (for example `2.3.1.`) instead of unordered bullets to keep references stable.
2.2.4. Assign unique subsection identifiers to every decision item so they can be cited precisely within other documents and code comments.

2.3. History maintenance and commits
2.3.1. Append a one-line summary for each new or updated decision file to the appropriate `HISTORY` file (`instructions/HISTORY` or `architecture/HISTORY`) immediately after authoring the decision.
2.3.2. Stage only the decision file and its `HISTORY` entry when committing; use `(INST)` or `(ARCH)` prefixes followed by the exact filename in the commit message.
2.3.3. When another instruction mandates a specific commit message, execute `git commit` with that exact message and include only the referenced files.

2.4. Instruction recompilation protocol
2.4.1. **When regrouping or recompiling instructions, preserve all mandatory language from the sources; escalate conflicts instead of weakening requirements.**
2.4.2. At the end of every recompiled file, include a numbered “Derived from” section listing all source instructions and clarifying the transformation when content is merged or expanded.
2.4.3. **Clarify ambiguities immediately** by methodically scanning every relevant instruction for conflicting requirements, inconsistent wording, unclear scope, or misleading implications; document any uncertainty you cannot resolve, halt publication, and request explicit user guidance before proceeding so that even less experienced readers can follow the reconciled result with confidence.
2.4.4. **Publish recompiled instruction sets across logically grouped files** so related guidance remains discoverable and maintainable.

2.5. Instruction proposals
2.5.1. Document reusable ideas as proposals in `instruction-proposals/`, applying the same naming convention but listing only the proposer as the author.
2.5.2. Do not enforce or commit proposals until the user explicitly approves them.
2.5.3. After approval, migrate the accepted content into the canonical decision directories, update the relevant `HISTORY`, and commit following section 2.3.
2.5.4. Leave rejected proposals in place unless the user instructs their removal.

2.6. Architecture deliverable format
2.6.1. Include a detailed tree representation with every architecture deliverable, capturing directories, modules, key files, and significant runtime components.
2.6.2. Annotate each node with concise responsibility notes when clarity is needed so future readers can understand the role of every element.
2.6.3. Update the tree whenever architecture decisions add, remove, or materially change components to keep the documentation authoritative.
2.6.4. Present the tree using ASCII or numbered indentation and supplement it with sections describing data flows, integration points, and operational characteristics referenced in the plan.
2.6.5. Regenerate or extend the architecture tree when new components emerge, existing ones change responsibilities, or dependencies are added or removed.
2.6.6. Capture the rationale for tree updates in accompanying architecture decisions so the history of changes remains traceable.

2.7. Reference identifier governance
2.7.1. **Ensure decision and architecture references remain unique** across instructions, plans, and code comments to prevent ambiguity.
2.7.2. When revising architecture decisions, append new identifiers rather than overwriting existing ones so historical references remain valid.
2.7.3. Before introducing a new architecture reference, verify it does not collide with identifiers recorded in architecture documents, progress plans, or code comments.
2.7.4. Maintain unique instruction identifiers (for example `INST-4.2.3`) across the project to prevent ambiguity when decisions are cited in plans or implementation notes.
2.7.5. Preserve historical instruction identifiers by adding new numbered items instead of renumbering or reassigning previous entries.
2.7.6. Confirm new instruction references are unused in existing documentation, task plans, or tooling scripts prior to publication.
2.7.7. Reject commits or task updates that reuse an existing architecture or instruction identifier until the duplication is resolved.
2.7.8. Update progress tracking artefacts and code comments if referenced identifiers are retired through superseding decisions, documenting the linkage to the new identifier.

Derived from
1. instructions/1 - 20251022T02:15:00 - Repository and environment stewardship (section 1.9.2)
2. instructions/2 - 20251022T02:16:00 - Decision governance and identifiers
3. User request on 2025-10-23 to restructure recompiled instructions across multiple files
